以下は、上記の英語ドキュメントを日本語に翻訳したものです。必要に応じてご自由に編集してください。

---

# Learn & Build a Javascript Blockchain

（学んで作る JavaScript ブロックチェーン）  
― ブロックチェーンを理解する最良の方法は、自分で作ってみること ―

**著者：Spenser Huang**  
**投稿日：2017 年 12 月 28 日**  
**読了時間：約 8 分**  
**いいね数：2.8K**

---

## はじめに

本シリーズ「Javascript Blockchain」のパート 1 では、ブロックオブジェクトとブロックチェーンオブジェクトについて解説し、その構造や意味合いについて議論します。

私は、技術を学ぶ最良の方法は実際に作ってみることだと固く信じています。もちろん、ブロックチェーン技術への興味から、自分自身でブロックチェーンを構築してみようと考えるようになりました。ブロックチェーンに興味がある皆さんに向けて、基本的なプルーフ・オブ・ワーク機構を内蔵したシンプルなブロックチェーンの作り方を順を追って解説していきます。解説の途中で、各機能の意味やその影響についても説明していきます。

**必要なもの**

- Node.js の最新バージョン（筆者は v8.7.0 を使用）
- npm (Node Package Manager)（筆者は v5.6.0 を使用）

**対象読者**

- ブロックチェーンに興味があり、JavaScript の基本的な知識を持っている方

**リポジトリについて**

- コードは [こちら](https://github.com/...) で公開されています。（※実際の URL に置き換えてください）

---

## Step 1: ブロックの構築

まず、`js-blockchain` というフォルダを作成し、その中に `main.js` というファイルを作成します。今回はソースコードをひとつのファイルにまとめているので、問題が発生した際はいつでもこのコードを参照できます。

### ブロックチェーンの構造

ブロックチェーンは、リンクリストとマークリーツリーを組み合わせることで構築されます。リンクリストの構造により、チェーンは順次新しいブロックを追加していくことが可能になり、これが「ブロックチェーン」という名称の由来にもなっています。つまり、ブロックチェーンは、各ブロックが前のブロックとリンクされた「鎖」そのものなのです。

ここで注目すべきは、従来のポインタのように前のブロックへの参照を直接持つのではなく、「前のブロックのハッシュ」を利用してリンクを形成している点です。

もし「ハッシュ」に馴染みがなければ、以下が簡単な説明です。  
**ハッシュとは**：入力に対して決定論的な関数を適用し、常に同じ出力（固定長の値）を得る仕組みです。通常、この関数は不可逆であり、出力から元の入力を導出するのは極めて困難です。これにより、ブロックチェーンではデータの不変性と整合性を保つための重要な役割を果たしています。

なお、今回のガイドでは、取引のマークリーツリーの実装は省略しています。

参考：[Bitcoin Blocks](http://learningspot.altervista.org/bitcoin-blocks/)

---

## Block オブジェクト

まず、**Block クラス** を作成します。このクラスは、以下の 3 つの主要な関数を持ちます。

- コンストラクタ関数
- `calculateHash` 関数
- `mineBlock` 関数

### コンストラクタ関数

コンストラクタ関数では、Block オブジェクトを生成すると同時に、必要なプロパティを設定します。

### ブロックの入力値

各ブロックオブジェクトは、**タイムスタンプ** と **ブロックデータ** を受け取ります。

- **タイムスタンプ**：ブロックが作成された日時を示します。例えば、Bitcoin（BTC）では、各ブロックの平均採掘時間が 10 分となるように難易度が調整されており、タイムスタンプはこの難易度調整のために利用されます。
- **ブロックデータ**：チェーン内に格納される情報が含まれます。BTC のような通貨では、ここに取引データがマークリーツリー形式で保存されます。

### ブロックのデータ構造

ブロックオブジェクトは、上記の 2 つの入力値に加え、さらに以下のプロパティを持ちます。

- **index**：チェーン内でのブロックの位置を示す番号
- **previousHash**：前のブロックのハッシュ値。これによりチェーンの整合性が保たれます。
- **hash**：ブロック自身のハッシュ値。`calculateHash` 関数によって算出されます。
- **nonce**：マイニング機構において重要な役割を果たす値で、今回は初期値として 0 を設定します。

**ポイント**：  
前のブロックのハッシュ値は、チェーン全体の整合性を保つためのものです。チェーンの整合性をチェックする際は、各ブロックのハッシュを再計算し、それが次のブロックに格納された `previousHash` と一致するかを確認します。ブロック内の情報が少しでも改ざんされれば、全く異なるハッシュが生成されるため、改ざんは容易に検出可能です。後ほど、この検証を行う `checkValid` 関数も作成します。

---

## Crypto-JS ライブラリの利用

ここでは、ブロックに `calculateHash` 関数を追加します。ハッシュ関数として、[crypto-js](https://www.npmjs.com/package/crypto-js) ライブラリの SHA256 ハッシュ関数を利用します。SHA256 は NSA により開発された不可逆なハッシュ関数で、BTC のプルーフ・オブ・ワークアルゴリズムやアドレス生成などで利用されています。

### crypto-js のインストール

ターミナルを開き、作成した `js-blockchain` フォルダに移動して、以下のコマンドでライブラリをインストールしてください。

```bash
npm install --save crypto-js
```

インストール後、以下のような出力が表示されるかもしれません。

```
npm WARN saveError ENOENT: no such file or directory, open '/Users/spenserhuang/Desktop/js-blockchain/package.json'
npm WARN enoent ENOENT: no such file or directory, open '/Users/spenserhuang/Desktop/js-blockchain/package.json'
npm WARN js-blockchain No description
npm WARN js-blockchain No repository field.
npm WARN js-blockchain No README data
npm WARN js-blockchain No license field.
+ crypto-js@3.1.9-1
updated 1 package in 1.75s
```

これらの警告は、今回のプロジェクトのコンテキストでは問題ありません。フォルダが最低限の状態であるため、`package.json` などが存在しないことによるものです。

### calculateHash の実装

ライブラリがインストールできたら、`require` を用いて SHA256 定数を作成し、ブロック内の全ての情報を入力としてハッシュを生成する `calculateHash` 関数を実装します。  
この関数は、ブロックオブジェクトの全プロパティを対象に SHA256 を適用し、結果を文字列に変換して返します。  
そのため、たとえ小さな変更（例：小数点の違い）でも、ハッシュ値は全く異なるものとなり、ブロックチェーンのセキュリティ向上に寄与します。

---

## Step 2: ブロックチェーンの構築

個々のブロックの構造ができたところで、次はそれらを連結し、通常のブロックチェーンに求められる基本機能を備えた **Blockchain クラス** を作成します。シンプルにするため、ブロックチェーンは以下の機能のみを持ちます。

- コンストラクタ関数
- `createGenesis` 関数
- `latestBlock` 関数
- `addBlock` 関数
- `checkValid` 関数

### Blockchain オブジェクトの概要

Blockchain クラスは、以下のような機能を提供する必要があります。

- インスタンス化（生成）できること
- チェーンの開始（Genesis ブロックの作成）
- 最新ブロックの情報にアクセスできること
- 新しいブロックを追加してチェーンを拡張できること

### コンストラクタ関数

まず、コンストラクタ関数で Blockchain オブジェクトを初期化します。ここでは、ブロックのリスト（配列）として `chain` プロパティを用意します。各ブロックの `index` は、チェーン内での位置を示すために使用されます。

### Genesis ブロックの作成

次に、チェーンの最初のブロックである **Genesis ブロック** を作成するための `createGenesis` 関数を実装します。  
ブロックチェーンの慣習では、最初のブロックは「Genesis ブロック」と呼ばれ、通常は手動でその内容が設定されます。

- **index**：0
- **timestamp** と **data**：例えば作成日と「Genesis block」など
- **previousHash**：前にハッシュが存在しないため、仮に "0" を設定

### 最新ブロックを取得する関数

`latestBlock` 関数は、チェーン内の最新のブロックの情報を取得するために用いられます。この機能は、後述する `addBlock` 関数の実装時に利用します。

### 新しいブロックの追加

ブロックチェーンは、情報が追加されるたびにチェーンがどんどん長くなっていく仕組みです。例えば、Bitcoin では約 10 分ごとに新しいブロックが生成され、そのブロックにその間の取引情報が格納されます。  
`addBlock` 関数では、以下の手順で新しいブロックを追加します。

1. 入力としてタイムスタンプやデータを既に持っている Block オブジェクトを受け取る
2. `latestBlock` 関数を使用して、新しいブロックに適切な **index** と **previousHash** を割り当てる
3. `calculateHash` 関数を用いて、新しいブロック自身のハッシュを計算する
4. 新しいブロックをチェーンに追加する

### チェーンの整合性検証

最後に、`checkValid` 関数を実装します。これは、チェーン内の各ブロックのハッシュが正しく計算され、前のブロックとの関連が保たれているかどうかを確認するためのものです。  
検証方法は以下の 2 点に分かれます。

- 現在のブロックの `hash` と、そのブロックの `calculateHash()` の結果が一致しているか
- 現在のブロックの `previousHash` と、前のブロックの `hash` が一致しているか

もし、ブロック内のいずれかの情報が改ざんされていれば、ハッシュ値は全く異なるものとなるため、容易に検出できます。

※ 注意点  
例えば、以下の条件文を使って「前のブロックのハッシュ」が正しいかどうかをチェックしようとすると：

```javascript
if (currentBlock.previousHash !== previousBlock.calculateHash()) {
  return false;
}
```

一見問題なさそうですが、`previousBlock` は実際のチェーン内のブロックとは別のオブジェクトであるため、同じ情報を持っていてもハッシュ値が異なる場合があります。実際のテストでは、例えば以下のようなハッシュの違いが見られました。

- 実際のブロックのハッシュ：  
  `0c27196c36691e915fb2a2f83e63867ec5042abfda4832b02383a6ab40aa075c`
- `previousBlock` のハッシュ：  
  `e6a312951e9e4ed6e4b2ef049246b282f71144599939ff6a5b97b0c53c941295`

このことから、ハッシュの敏感さがうかがえます。

---

## 全体のコード例

これまでの説明を踏まえると、最終的なプログラムは以下のような形になります。（実際のコード例は、リポジトリ内のソースコードを参照してください。）

最後に、以下のようなコードを `main.js` の末尾に追加してブロックチェーンの動作をテストします。

```javascript
// 例: ブロックチェーンに新しいブロックを追加するコード
```

その後、ターミナルで以下のコマンドを実行してください。

```bash
node main.js
```

実行結果は、以下のような JSON 出力が表示されるはずです。

```json
{
    "chain": [
        {
            "index": 0,
            "timestamp": 0,
            "data": "01/01/2017",
            "previousHash": "Genesis block",
            "hash": "8163cbd8feafd38a96cd193f2b44940473c22b21ddbb7445bd99ee310dac28ae",
            "nonce": 0
        },
        {
            "index": 1,
            "timestamp": "12/25/2017",
            "data": {
                "amount": 5
            },
            "previousHash": "8163cbd8feafd38a96cd193f2b44940473c22b21ddbb7445bd99ee310dac28ae",
            "hash": "744ce201216f78bba5b87e371579898b97e473ac644d6a13ddda9cdbe05100f6",
            "nonce": 0
        },
        {
            "index": 2,
            "timestamp": "12/26/2017",
            "data": {
                "amount": 10
            },
            "previousHash": "744ce201216f78bba5b87e371579898b97e473ac644d6a13ddda9cdbe05100f6",
            "hash": "9e3cf69ee7a3f3f651b33500ea3f32ccf1a13590115c6739dda74920d54702c8",
            "nonce": 0
        }
    ]
}
Is blockchain valid? true
```

---

## まとめ

これで、機能するブロックチェーンのバージョン 1 が完成しました！  
ただし、このブロックチェーンには小さなセキュリティ上の問題が存在しています。ぜひこのコードを実際に動かしてみて、データの改ざんなどを試しながら、どこにセキュリティの脆弱性があるのかを探ってみてください。

**ヒント**：  
このセキュリティの問題は、今回のパートではまだ実装していない「マイニング機能」の実装に深く関係しています。パート 2 で詳しく解説する予定です。

Happy coding and exploring!  
（楽しくコーディングして、ブロックチェーンの世界を探求しましょう！）

---

以上が、日本語に翻訳したドキュメントです。もし不明な点や追加の修正が必要な部分があれば、お知らせください。
